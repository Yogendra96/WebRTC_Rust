
<!DOCTYPE html>
<html>
<head>
    <title>Random Video Chat</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="Professional WebRTC video chat application with user authentication and advanced features">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="VideoChat">
    <link rel="manifest" href="/static/manifest.json">
    <link rel="apple-touch-icon" href="https://via.placeholder.com/180x180/667eea/ffffff?text=VC">
    <style>
        body { margin: 0; font-family: Arial, sans-serif; background: #f0f0f0; }
        .container { max-width: 900px; margin: 20px auto; text-align: center; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        #localVideo, #remoteVideo { width: 350px; height: 250px; background: #333; margin: 10px; border-radius: 8px; }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            .container { margin: 10px; padding: 15px; max-width: none; }
            #localVideo, #remoteVideo { width: 280px; height: 200px; margin: 5px; }
            #videoControls { flex-wrap: wrap; gap: 5px; }
            #videoControls button { padding: 6px 10px; font-size: 12px; }
            #chatArea { max-width: 300px; }
            #chatMessages { height: 120px; }
            .auth-container { margin: 10px; }
        }
        
        @media (max-width: 480px) {
            #localVideo, #remoteVideo { width: 240px; height: 160px; }
            h1 { font-size: 1.5em; }
            #videoControls button { padding: 5px 8px; font-size: 11px; }
        }
        #startButton, #cancelButton, #nextButton, #sendButton { 
            padding: 10px 20px; font-size: 16px; cursor: pointer; margin: 5px;
            background: #4CAF50; color: white; border: none; border-radius: 5px;
        }
        #cancelButton, #nextButton { background: #f44336; }
        #connectionStatus { 
            background: #e7e7e7; padding: 10px; border-radius: 5px; margin: 10px 0;
            font-weight: bold;
        }
        #waitingRoom { 
            background: #fff3cd; padding: 20px; border-radius: 8px; margin: 20px 0;
            border: 1px solid #ffeaa7;
        }
        #chatArea {
            margin-top: 20px; text-align: left; max-width: 400px; margin-left: auto; margin-right: auto;
        }
        #chatMessages {
            height: 150px; overflow-y: scroll; border: 1px solid #ddd; padding: 10px;
            background: #f9f9f9; border-radius: 5px; margin-bottom: 10px;
        }
        #chatInput {
            width: calc(100% - 80px); padding: 8px; border: 1px solid #ddd; border-radius: 3px;
        }
        .chat-message {
            margin: 5px 0; padding: 5px; border-radius: 3px;
        }
        .chat-message.own {
            background: #dcf8c6; text-align: right;
        }
        .chat-message.other {
            background: #e5e5ea;
        }
        #videoControls {
            display: flex; justify-content: center; align-items: center; gap: 10px; margin: 10px 0;
            padding: 10px; background: #f8f9fa; border-radius: 8px;
        }
        #videoControls button {
            padding: 8px 12px; font-size: 14px; border: none; border-radius: 5px;
            cursor: pointer; background: #007bff; color: white;
        }
        #videoControls button:hover { background: #0056b3; }
        #videoControls button.disabled { background: #6c757d; }
        #connectionQuality {
            font-size: 14px; font-weight: bold;
        }
        .quality-excellent { color: #28a745; }
        .quality-good { color: #ffc107; }
        .quality-poor { color: #dc3545; }
        
        /* Recording controls */
        .recording-controls {
            display: flex; gap: 5px; align-items: center;
        }
        .recording-indicator {
            width: 10px; height: 10px; background: #dc3545; 
            border-radius: 50%; animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        .screenshot-preview {
            position: fixed; top: 20px; right: 20px; width: 200px; height: 150px;
            border: 2px solid #007bff; border-radius: 8px; background: white;
            z-index: 1000; display: none; flex-direction: column; align-items: center;
            padding: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .screenshot-preview img {
            max-width: 100%; max-height: 100px; border-radius: 4px;
        }
        .screenshot-actions {
            margin-top: 10px; display: flex; gap: 5px;
        }
        .screenshot-actions button {
            padding: 4px 8px; font-size: 10px; border: none; border-radius: 3px;
            cursor: pointer; background: #007bff; color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Random Video Chat</h1>
        <div id="userInfo" style="margin: 10px 0; font-size: 14px; color: #666;">
            <span id="welcomeMessage">Welcome, Guest</span>
            <button id="logoutButton" style="margin-left: 10px; font-size: 12px; padding: 5px 10px;">Logout</button>
        </div>
        <div id="connectionStatus">Not connected</div>
        <div id="preferences" style="margin: 10px 0;">
            <button id="settingsButton">‚öôÔ∏è Settings</button>
            <button id="createRoomButton">üè† Create Private Room</button>
            <button id="joinRoomButton">üîë Join Room</button>
        </div>
        <div id="settingsModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); z-index: 1000;">
            <h3>Settings</h3>
            <div>
                <label><input type="checkbox" id="autoStartVideo" checked> Auto-start video</label><br>
                <label><input type="checkbox" id="autoStartAudio" checked> Auto-start audio</label><br>
                <label>Video Quality: 
                    <select id="videoQuality">
                        <option value="720p">720p (HD)</option>
                        <option value="480p" selected>480p</option>
                        <option value="360p">360p</option>
                    </select>
                </label><br><br>
                <button id="saveSettings">Save</button>
                <button id="closeSettings">Cancel</button>
            </div>
        </div>
        <div id="settingsOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"></div>
        
        <!-- Room Creation Modal -->
        <div id="roomModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); z-index: 1000;">
            <h3>Create Private Room</h3>
            <div>
                <label>Room Name (Optional): 
                    <input type="text" id="roomName" placeholder="My Private Room" style="width: 100%; margin: 10px 0; padding: 8px;">
                </label><br>
                <label>Room Type: 
                    <select id="roomType" style="width: 100%; margin: 10px 0; padding: 8px;">
                        <option value="private">Private (Invite Code Required)</option>
                        <option value="public">Public (Anyone Can Join)</option>
                    </select>
                </label><br><br>
                <button id="createRoomConfirm">Create Room</button>
                <button id="closeRoomModal">Cancel</button>
            </div>
        </div>
        
        <!-- Join Room Modal -->
        <div id="joinRoomModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); z-index: 1000;">
            <h3>Join Private Room</h3>
            <div>
                <label>Invite Code: 
                    <input type="text" id="inviteCode" placeholder="123456" style="width: 100%; margin: 10px 0; padding: 8px;" maxlength="6">
                </label><br><br>
                <button id="joinRoomConfirm">Join Room</button>
                <button id="closeJoinRoomModal">Cancel</button>
            </div>
        </div>
        
        <!-- Room Info Display -->
        <div id="roomInfo" style="display: none; background: #e3f2fd; padding: 10px; border-radius: 5px; margin: 10px 0;">
            <div>üè† Room: <span id="currentRoomName">-</span></div>
            <div>üîë Invite Code: <span id="currentInviteCode">-</span></div>
            <button id="leaveRoomButton" style="margin-top: 5px; background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 3px;">Leave Room</button>
        </div>
        
        <div id="roomOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"></div>
        <button id="startButton">Start New Chat</button>
        <div id="waitingRoom" style="display: none;">
            <h2>Looking for a partner...</h2>
            <div id="waitingMessage">Connecting to matching service...</div>
            <button id="cancelButton">Cancel</button>
        </div>
        <div id="videoArea" style="display: none;">
            <div id="videoControls">
                <button id="toggleVideo">üìπ Video</button>
                <button id="toggleAudio">üé§ Audio</button>
                <button id="shareScreen">üì∫ Share Screen</button>
                <div class="recording-controls">
                    <button id="recordButton">üî¥ Record</button>
                    <button id="screenshotButton">üì∏ Screenshot</button>
                    <div id="recordingIndicator" class="recording-indicator" style="display: none;"></div>
                </div>
                <div id="connectionQuality">üì∂ Quality: <span id="qualityStatus">Unknown</span></div>
            </div>
            <video id="localVideo" autoplay muted playsinline></video>
            <video id="remoteVideo" autoplay playsinline></video>
            <div id="chatArea">
                <div id="chatMessages"></div>
                <input type="text" id="chatInput" placeholder="Type a message..." maxlength="500">
                <button id="sendButton">Send</button>
            </div>
            <div style="display: flex; justify-content: center; gap: 10px; margin-top: 10px;">
                <button id="nextButton">Next Partner</button>
                <button id="reportButton" style="background: #dc3545;">üö® Report User</button>
            </div>
        </div>
        <div id="error" style="display: none; color: red; margin: 10px 0;"></div>
    </div>
    
    <!-- Screenshot preview -->
    <div id="screenshotPreview" class="screenshot-preview">
        <img id="screenshotImage" src="" alt="Screenshot">
        <div class="screenshot-actions">
            <button id="downloadScreenshot">üì• Download</button>
            <button id="shareScreenshot">üì§ Share</button>
            <button id="closeScreenshot">‚ùå Close</button>
        </div>
    </div>
    <script>
        const ws = new WebSocket(`ws://${window.location.host}/ws`);
        let localStream;
        let peerConnection;
        let myId;
        let partnerId;
        let isWaiting = false;
        let isInCall = false;
        let isVideoEnabled = true;
        let isAudioEnabled = true;
        let isScreenSharing = false;
        let qualityCheckInterval;
        let userSettings = {
            autoStartVideo: true,
            autoStartAudio: true,
            videoQuality: '480p'
        };
        let currentUser = null;
        let authToken = null;
        let currentRoom = null;
        let isInPrivateRoom = false;
        let reconnectionAttempts = 0;
        let maxReconnectionAttempts = 5;
        let reconnectionDelay = 1000; // Start with 1 second
        let reconnectionTimer = null;
        
        // Recording and screenshot variables
        let mediaRecorder = null;
        let recordedChunks = [];
        let isRecording = false;
        let recordingStartTime = null;
        
        function displayError(message, code) {
            const errorDiv = document.getElementById('error');
            if (code) {
                errorDiv.textContent = `Error [${code}]: ${message}`;
            } else {
                errorDiv.textContent = message;
            }
            errorDiv.style.display = 'block';
            errorDiv.classList.add('error-shake');
            
            // Log to console for debugging
            console.error(`WebRTC Error: ${message}`, code ? `(Code: ${code})` : '');
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                errorDiv.style.display = 'none';
                errorDiv.classList.remove('error-shake');
            }, 5000);
        }
        
        // Add CSS for error animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes error-shake {
                0% { transform: translateX(0); }
                25% { transform: translateX(-5px); }
                50% { transform: translateX(5px); }
                75% { transform: translateX(-5px); }
                100% { transform: translateX(0); }
            }
            .error-shake {
                animation: error-shake 0.5s ease-in-out;
                background-color: #ffdddd;
                border-left: 4px solid #f44336;
                padding-left: 10px;
            }
        `;
        document.head.appendChild(style);

        // Default configuration with fallback STUN server
        let configuration = {
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        };
        
        // Track connection attempts for fallback mechanism
        let connectionAttempts = 0;
        const MAX_CONNECTION_ATTEMPTS = 3;
        
        // WebSocket connection error handling with reconnection
        ws.onerror = function(error) {
            console.error('WebSocket error:', error);
            updateConnectionStatus('Connection error - attempting to reconnect...');
            scheduleReconnection();
        };
        
        ws.onclose = function(event) {
            console.log('WebSocket closed:', event.code, event.reason);
            if (!event.wasClean) {
                updateConnectionStatus('Connection lost - reconnecting...');
                scheduleReconnection();
            }
        };
        
        ws.onopen = function(event) {
            console.log('WebSocket connected');
            reconnectionAttempts = 0;
            reconnectionDelay = 1000;
            if (reconnectionTimer) {
                clearTimeout(reconnectionTimer);
                reconnectionTimer = null;
            }
        };
        
        function scheduleReconnection() {
            if (reconnectionTimer) {
                clearTimeout(reconnectionTimer);
            }
            
            if (reconnectionAttempts >= maxReconnectionAttempts) {
                updateConnectionStatus('Connection failed - please refresh the page');
                displayError('Unable to maintain connection. Please refresh the page to continue.');
                return;
            }
            
            reconnectionAttempts++;
            const delay = Math.min(reconnectionDelay * Math.pow(2, reconnectionAttempts - 1), 30000); // Max 30 seconds
            
            updateConnectionStatus(`Reconnecting in ${Math.ceil(delay / 1000)} seconds... (${reconnectionAttempts}/${maxReconnectionAttempts})`);
            
            reconnectionTimer = setTimeout(() => {
                attemptReconnection();
            }, delay);
        }
        
        function attemptReconnection() {
            console.log(`Attempting reconnection ${reconnectionAttempts}/${maxReconnectionAttempts}`);
            updateConnectionStatus('Attempting to reconnect...');
            
            // Create new WebSocket connection
            const newWs = new WebSocket(`ws://${window.location.host}/ws`);
            
            newWs.onopen = function(event) {
                console.log('Reconnection successful');
                updateConnectionStatus('Reconnected successfully');
                
                // Replace the old WebSocket
                ws.onopen = newWs.onopen;
                ws.onmessage = newWs.onmessage;
                ws.onerror = newWs.onerror;
                ws.onclose = newWs.onclose;
                
                // Reset reconnection state
                reconnectionAttempts = 0;
                reconnectionDelay = 1000;
                
                // Re-authenticate if needed
                if (currentUser) {
                    updateConnectionStatus(`Reconnected as ${currentUser.display_name || currentUser.username}`);
                }
            };
            
            newWs.onerror = function(error) {
                console.error('Reconnection failed:', error);
                scheduleReconnection();
            };
            
            newWs.onclose = function(event) {
                if (!event.wasClean && reconnectionAttempts < maxReconnectionAttempts) {
                    scheduleReconnection();
                }
            };
            
            newWs.onmessage = ws.onmessage; // Use the same message handler
        }

        function updateConnectionStatus(status) {
            document.getElementById('connectionStatus').textContent = status;
        }

        function showWaitingRoom() {
            document.getElementById('waitingRoom').style.display = 'block';
            document.getElementById('startButton').style.display = 'none';
            isWaiting = true;
        }

        function hideWaitingRoom() {
            document.getElementById('waitingRoom').style.display = 'none';
            document.getElementById('startButton').style.display = 'inline-block';
            isWaiting = false;
        }

        function showVideoArea() {
            document.getElementById('videoArea').style.display = 'block';
            document.getElementById('waitingRoom').style.display = 'none';
            document.getElementById('startButton').style.display = 'none';
            isInCall = true;
        }

        function hideVideoArea() {
            document.getElementById('videoArea').style.display = 'none';
            document.getElementById('startButton').style.display = 'inline-block';
            document.getElementById('remoteVideo').srcObject = null;
            isInCall = false;
        }

        async function startChat() {
            try {
                updateConnectionStatus('Getting media access...');
                const constraints = getVideoConstraints();
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                document.getElementById('localVideo').srcObject = localStream;
                updateConnectionStatus('Looking for partner...');
                
                // Set initial button states based on user preferences
                isVideoEnabled = userSettings.autoStartVideo;
                isAudioEnabled = userSettings.autoStartAudio;
                
                // Request partner matching
                sendMessage({
                    message_type: 'find-partner',
                    target: '',
                    data: 'Looking for a partner'
                });
                
                showWaitingRoom();
            } catch (e) {
                console.error('Error accessing media devices:', e);
                displayError(`Could not access camera or microphone: ${e.message || 'Permission denied'}`);
                updateConnectionStatus('Media access denied');
            }
        }

        function addChatMessage(content, isOwn = false) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${isOwn ? 'own' : 'other'}`;
            messageDiv.textContent = content;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            if (message && partnerId) {
                sendMessage({
                    target: partnerId,
                    message_type: 'chat',
                    data: message
                });
                addChatMessage(message, true);
                input.value = '';
            }
        }

        async function toggleVideo() {
            const button = document.getElementById('toggleVideo');
            if (localStream) {
                const videoTrack = localStream.getVideoTracks()[0];
                if (videoTrack) {
                    isVideoEnabled = !isVideoEnabled;
                    videoTrack.enabled = isVideoEnabled;
                    button.textContent = isVideoEnabled ? 'üìπ Video' : 'üìπ Video (Off)';
                    button.className = isVideoEnabled ? '' : 'disabled';
                }
            }
        }

        async function toggleAudio() {
            const button = document.getElementById('toggleAudio');
            if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                if (audioTrack) {
                    isAudioEnabled = !isAudioEnabled;
                    audioTrack.enabled = isAudioEnabled;
                    button.textContent = isAudioEnabled ? 'üé§ Audio' : 'üé§ Audio (Off)';
                    button.className = isAudioEnabled ? '' : 'disabled';
                }
            }
        }

        async function toggleScreenShare() {
            const button = document.getElementById('shareScreen');
            try {
                if (!isScreenSharing) {
                    // Start screen sharing
                    const screenStream = await navigator.mediaDevices.getDisplayMedia({ 
                        video: true, 
                        audio: true 
                    });
                    
                    // Replace video track in peer connection
                    if (peerConnection) {
                        const sender = peerConnection.getSenders().find(s => 
                            s.track && s.track.kind === 'video'
                        );
                        if (sender) {
                            await sender.replaceTrack(screenStream.getVideoTracks()[0]);
                        }
                    }
                    
                    // Update local video
                    document.getElementById('localVideo').srcObject = screenStream;
                    
                    // Handle screen share ending
                    screenStream.getVideoTracks()[0].onended = async () => {
                        await stopScreenShare();
                    };
                    
                    isScreenSharing = true;
                    button.textContent = 'üì∫ Stop Sharing';
                    button.className = 'disabled';
                } else {
                    await stopScreenShare();
                }
            } catch (e) {
                console.error('Error sharing screen:', e);
                displayError('Screen sharing not supported or permission denied');
            }
        }

        async function stopScreenShare() {
            if (localStream && peerConnection) {
                // Replace screen share with camera
                const videoTrack = localStream.getVideoTracks()[0];
                const sender = peerConnection.getSenders().find(s => 
                    s.track && s.track.kind === 'video'
                );
                if (sender && videoTrack) {
                    await sender.replaceTrack(videoTrack);
                }
                
                document.getElementById('localVideo').srcObject = localStream;
                isScreenSharing = false;
                document.getElementById('shareScreen').textContent = 'üì∫ Share Screen';
                document.getElementById('shareScreen').className = '';
            }
        }

        function startQualityMonitoring() {
            if (qualityCheckInterval) {
                clearInterval(qualityCheckInterval);
            }
            
            qualityCheckInterval = setInterval(async () => {
                if (peerConnection) {
                    try {
                        const stats = await peerConnection.getStats();
                        let inboundRtp = null;
                        
                        stats.forEach(report => {
                            if (report.type === 'inbound-rtp' && report.mediaType === 'video') {
                                inboundRtp = report;
                            }
                        });
                        
                        if (inboundRtp) {
                            const quality = calculateQuality(inboundRtp);
                            updateQualityDisplay(quality);
                        }
                    } catch (e) {
                        console.warn('Error getting connection stats:', e);
                    }
                }
            }, 2000);
        }

        function calculateQuality(stats) {
            // Simple quality calculation based on packet loss and jitter
            const packetLoss = stats.packetsLost || 0;
            const packetsReceived = stats.packetsReceived || 1;
            const lossRate = packetLoss / (packetLoss + packetsReceived);
            
            if (lossRate < 0.02) return 'excellent';
            if (lossRate < 0.05) return 'good';
            return 'poor';
        }

        function updateQualityDisplay(quality) {
            const statusElement = document.getElementById('qualityStatus');
            const qualityElement = document.getElementById('connectionQuality');
            
            // Remove old classes
            qualityElement.className = '';
            
            switch (quality) {
                case 'excellent':
                    statusElement.textContent = 'Excellent';
                    qualityElement.classList.add('quality-excellent');
                    break;
                case 'good':
                    statusElement.textContent = 'Good';
                    qualityElement.classList.add('quality-good');
                    break;
                case 'poor':
                    statusElement.textContent = 'Poor';
                    qualityElement.classList.add('quality-poor');
                    break;
                default:
                    statusElement.textContent = 'Unknown';
            }
        }

        function loadSettings() {
            const saved = localStorage.getItem('webrtc-settings');
            if (saved) {
                userSettings = { ...userSettings, ...JSON.parse(saved) };
                document.getElementById('autoStartVideo').checked = userSettings.autoStartVideo;
                document.getElementById('autoStartAudio').checked = userSettings.autoStartAudio;
                document.getElementById('videoQuality').value = userSettings.videoQuality;
            }
        }

        function saveSettings() {
            userSettings.autoStartVideo = document.getElementById('autoStartVideo').checked;
            userSettings.autoStartAudio = document.getElementById('autoStartAudio').checked;
            userSettings.videoQuality = document.getElementById('videoQuality').value;
            
            localStorage.setItem('webrtc-settings', JSON.stringify(userSettings));
            closeSettingsModal();
        }

        function openSettingsModal() {
            document.getElementById('settingsOverlay').style.display = 'block';
            document.getElementById('settingsModal').style.display = 'block';
        }

        function closeSettingsModal() {
            document.getElementById('settingsOverlay').style.display = 'none';
            document.getElementById('settingsModal').style.display = 'none';
        }

        function getVideoConstraints() {
            const constraints = { audio: userSettings.autoStartAudio };
            
            if (userSettings.autoStartVideo) {
                switch (userSettings.videoQuality) {
                    case '720p':
                        constraints.video = { width: 1280, height: 720 };
                        break;
                    case '480p':
                        constraints.video = { width: 640, height: 480 };
                        break;
                    case '360p':
                        constraints.video = { width: 480, height: 360 };
                        break;
                    default:
                        constraints.video = true;
                }
            } else {
                constraints.video = false;
            }
            
            return constraints;
        }

        function initiatePeerConnection() {
            try {
                // Close any existing connection
                if (peerConnection) {
                    peerConnection.close();
                }
                
                console.log('Creating peer connection with configuration:', 
                    JSON.stringify(configuration.iceServers.map(s => ({ urls: s.urls, hasAuth: !!s.username }))));
                peerConnection = new RTCPeerConnection(configuration);
                
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                peerConnection.ontrack = event => {
                    document.getElementById('remoteVideo').srcObject = event.streams[0];
                };

                peerConnection.onicecandidate = event => {
                    if (event.candidate) {
                        sendMessage({
                            target: partnerId,
                            message_type: 'ice-candidate',
                            data: JSON.stringify(event.candidate)
                        });
                    }
                };
                
                // Monitor ICE connection state for fallback mechanism
                peerConnection.oniceconnectionstatechange = () => {
                    console.log('ICE connection state:', peerConnection.iceConnectionState);
                    
                    if (peerConnection.iceConnectionState === 'failed') {
                        console.warn(`ICE connection failed (attempt ${connectionAttempts + 1}/${MAX_CONNECTION_ATTEMPTS})`);
                        
                        // Try reconnecting with different transport options if we haven't exceeded max attempts
                        if (connectionAttempts < MAX_CONNECTION_ATTEMPTS) {
                            connectionAttempts++;
                            console.log('Attempting connection with different transport options...');
                            
                            // Prioritize TCP if UDP is failing
                            if (connectionAttempts === 1) {
                                // Reorder ICE servers to prioritize TCP transports
                                configuration.iceServers.forEach(server => {
                                    if (Array.isArray(server.urls)) {
                                        // Move TCP URLs to the front
                                        server.urls.sort((a, b) => {
                                            return a.includes('tcp') ? -1 : b.includes('tcp') ? 1 : 0;
                                        });
                                    }
                                });
                            }
                            
                            // Restart ICE gathering with the modified configuration
                            initiatePeerConnection();
                            createOffer();
                        } else {
                            displayError('Connection failed after multiple attempts. Please check your network or try again later.');
                        }
                    } else if (peerConnection.iceConnectionState === 'connected' || 
                              peerConnection.iceConnectionState === 'completed') {
                        console.log('ICE connection established successfully');
                        connectionAttempts = 0; // Reset counter on success
                        startQualityMonitoring(); // Start monitoring connection quality
                    }
                };
                
                peerConnection.onicecandidateerror = event => {
                    console.error('ICE candidate error:', event);
                };
                
                peerConnection.onconnectionstatechange = event => {
                    if (peerConnection.connectionState === 'failed' || 
                        peerConnection.connectionState === 'disconnected' || 
                        peerConnection.connectionState === 'closed') {
                        displayError(`Connection failed: ${peerConnection.connectionState}`);
                    }
                };

                createOffer();
            } catch (e) {
                console.error('Error setting up peer connection:', e);
                displayError(`Failed to setup connection: ${e.message}`);
            }
        }

        async function createOffer() {
            try {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                sendMessage({
                    target: partnerId,
                    message_type: 'offer',
                    data: JSON.stringify(offer)
                });
            } catch (e) {
                console.error('Error creating offer:', e);
                displayError(`Failed to create connection offer: ${e.message}`);
            }
        }

        function sendMessage(message) {
            try {
                if (ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify(message));
                } else {
                    displayError('WebSocket is not connected');
                }
            } catch (e) {
                console.error('Error sending message:', e);
                displayError(`Failed to send message: ${e.message}`);
            }
        }

        ws.onmessage = async function(event) {
            try {
                const message = JSON.parse(event.data);
                
                if (message.message_type === 'error') {
                    // Handle structured error messages with code
                    displayError(message.error, message.code);
                    console.debug('Error details:', message.details || 'No additional details');
                    return;
                }
                
                if (message.message_type === 'connected') {
                    // Store my ID
                    myId = message.data;
                    console.log('Connected with ID:', myId);
                    updateConnectionStatus('Connected - Ready to chat');
                    
                    // Update ICE servers configuration if provided by the server
                    if (message.ice_servers && Array.isArray(message.ice_servers)) {
                        console.log('Received ICE server configuration from server');
                        configuration.iceServers = message.ice_servers;
                        
                        // Log the servers for debugging (without credentials)
                        const serverUrls = configuration.iceServers.map(server => {
                            return {
                                urls: server.urls,
                                hasCredentials: !!(server.username && server.credential)
                            };
                        });
                        console.log('Using ICE servers:', serverUrls);
                    }
                } else if (message.message_type === 'waiting') {
                    document.getElementById('waitingMessage').textContent = message.data;
                } else if (message.message_type === 'partner-found') {
                    partnerId = message.partner_id;
                    updateConnectionStatus(`Connected to partner: ${partnerId.substring(0, 8)}...`);
                    showVideoArea();
                    initiatePeerConnection();
                } else if (message.message_type === 'chat') {
                    addChatMessage(message.content, false);
                } else if (message.message_type === 'offer') {
                    try {
                        const offer = JSON.parse(message.data);
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                        
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        
                        sendMessage({
                            target: message.source,
                            message_type: 'answer',
                            data: JSON.stringify(answer)
                        });
                    } catch (e) {
                        console.error('Error processing offer:', e);
                        displayError(`Failed to process connection offer: ${e.message}`);
                    }
                } else if (message.message_type === 'answer') {
                    try {
                        const answer = JSON.parse(message.data);
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                    } catch (e) {
                        console.error('Error processing answer:', e);
                        displayError(`Failed to process connection answer: ${e.message}`);
                    }
                } else if (message.message_type === 'ice-candidate') {
                    try {
                        const candidate = JSON.parse(message.data);
                        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    } catch (e) {
                        console.error('Error adding ICE candidate:', e);
                        // Don't show this error to user as it's common and often recoverable
                    }
                } else if (message.message_type === 'error') {
                    displayError(`Server message: ${message.data}`);
                }
            } catch (e) {
                console.error('Error processing message:', e);
                displayError(`Failed to process message: ${e.message}`);
            }
        };

        document.getElementById('startButton').onclick = startChat;
        document.getElementById('cancelButton').onclick = function() {
            hideWaitingRoom();
            updateConnectionStatus('Connected - Ready to chat');
        };
        document.getElementById('nextButton').onclick = function() {
            // End current call and find new partner
            if (peerConnection) {
                peerConnection.close();
            }
            hideVideoArea();
            partnerId = null;
            startChat();
        };
        document.getElementById('sendButton').onclick = sendChatMessage;
        document.getElementById('chatInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendChatMessage();
            }
        });
        document.getElementById('toggleVideo').onclick = toggleVideo;
        document.getElementById('toggleAudio').onclick = toggleAudio;
        document.getElementById('shareScreen').onclick = toggleScreenShare;
        document.getElementById('settingsButton').onclick = openSettingsModal;
        document.getElementById('saveSettings').onclick = saveSettings;
        document.getElementById('closeSettings').onclick = closeSettingsModal;
        document.getElementById('settingsOverlay').onclick = closeSettingsModal;
        
        // Load settings on page load
        loadSettings();
        
        // Authentication functions
        function checkAuthentication() {
            authToken = localStorage.getItem('auth-token');
            const userInfo = localStorage.getItem('user-info');
            
            if (!authToken || !userInfo) {
                // Redirect to login
                window.location.href = '/login.html';
                return false;
            }
            
            try {
                currentUser = JSON.parse(userInfo);
                document.getElementById('welcomeMessage').textContent = 
                    `Welcome, ${currentUser.display_name || currentUser.username}`;
                
                // Verify token is still valid
                fetch('/api/profile', {
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                })
                .then(response => {
                    if (!response.ok) {
                        // Token expired or invalid
                        logout();
                    }
                })
                .catch(() => {
                    logout();
                });
                
                return true;
            } catch (e) {
                logout();
                return false;
            }
        }
        
        function logout() {
            localStorage.removeItem('auth-token');
            localStorage.removeItem('user-info');
            window.location.href = '/login.html';
        }
        
        // Report user function
        async function reportUser(reportedUserId, reportType, description) {
            if (!authToken) {
                displayError('You must be logged in to report users');
                return;
            }
            
            try {
                const response = await fetch('/api/report', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({
                        reported_user_id: reportedUserId,
                        report_type: reportType,
                        description: description,
                        room_id: null
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    alert('User reported successfully. Thank you for helping keep our community safe.');
                } else {
                    displayError('Failed to submit report');
                }
            } catch (error) {
                displayError('Error submitting report');
            }
        }
        
        document.getElementById('logoutButton').onclick = logout;
        document.getElementById('reportButton').onclick = function() {
            if (partnerId) {
                const reason = prompt('Why are you reporting this user?\n\n1. Inappropriate content\n2. Harassment\n3. Spam\n4. Other\n\nPlease enter a number (1-4) and description:');
                if (reason) {
                    const reportTypes = ['inappropriate_content', 'harassment', 'spam', 'other'];
                    const typeIndex = parseInt(reason.charAt(0)) - 1;
                    const reportType = reportTypes[typeIndex] || 'other';
                    const description = reason.length > 2 ? reason.substring(2) : reason;
                    
                    reportUser(partnerId, reportType, description);
                }
            } else {
                alert('No user to report');
            }
        };
        
        // Room management functions
        function openRoomModal() {
            document.getElementById('roomOverlay').style.display = 'block';
            document.getElementById('roomModal').style.display = 'block';
        }
        
        function closeRoomModal() {
            document.getElementById('roomOverlay').style.display = 'none';
            document.getElementById('roomModal').style.display = 'none';
        }
        
        function openJoinRoomModal() {
            document.getElementById('roomOverlay').style.display = 'block';
            document.getElementById('joinRoomModal').style.display = 'block';
        }
        
        function closeJoinRoomModal() {
            document.getElementById('roomOverlay').style.display = 'none';
            document.getElementById('joinRoomModal').style.display = 'none';
        }
        
        async function createRoom() {
            if (!authToken) {
                displayError('You must be logged in to create rooms');
                return;
            }
            
            const roomName = document.getElementById('roomName').value.trim() || null;
            const roomType = document.getElementById('roomType').value;
            
            try {
                const response = await fetch('/api/rooms', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({
                        name: roomName,
                        room_type: roomType
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    currentRoom = result.room;
                    isInPrivateRoom = true;
                    
                    // Update UI
                    document.getElementById('currentRoomName').textContent = currentRoom.name || 'Unnamed Room';
                    document.getElementById('currentInviteCode').textContent = currentRoom.invite_code || 'N/A';
                    document.getElementById('roomInfo').style.display = 'block';
                    
                    closeRoomModal();
                    
                    if (currentRoom.invite_code) {
                        alert(`Room created! Invite code: ${currentRoom.invite_code}\nShare this code with others to join your room.`);
                    }
                    
                    // Start waiting for someone to join
                    updateConnectionStatus('Waiting for someone to join your room...');
                } else {
                    displayError(result.error || 'Failed to create room');
                }
            } catch (error) {
                displayError('Error creating room');
                console.error('Room creation error:', error);
            }
        }
        
        async function joinRoom() {
            if (!authToken) {
                displayError('You must be logged in to join rooms');
                return;
            }
            
            const inviteCode = document.getElementById('inviteCode').value.trim();
            if (!inviteCode) {
                displayError('Please enter an invite code');
                return;
            }
            
            try {
                const response = await fetch('/api/rooms/join', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({
                        invite_code: inviteCode
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    currentRoom = result.room;
                    isInPrivateRoom = true;
                    
                    // Update UI
                    document.getElementById('currentRoomName').textContent = currentRoom.name || 'Unnamed Room';
                    document.getElementById('currentInviteCode').textContent = currentRoom.invite_code || 'N/A';
                    document.getElementById('roomInfo').style.display = 'block';
                    
                    closeJoinRoomModal();
                    updateConnectionStatus('Joined room successfully!');
                    
                    // Start looking for media access
                    startChat();
                } else {
                    displayError(result.error || 'Failed to join room');
                }
            } catch (error) {
                displayError('Error joining room');
                console.error('Room join error:', error);
            }
        }
        
        function leaveRoom() {
            currentRoom = null;
            isInPrivateRoom = false;
            document.getElementById('roomInfo').style.display = 'none';
            updateConnectionStatus('Left room');
            
            // End current call if in progress
            if (peerConnection) {
                peerConnection.close();
            }
            hideVideoArea();
            partnerId = null;
        }
        
        // Event listeners for room management
        document.getElementById('createRoomButton').onclick = openRoomModal;
        document.getElementById('joinRoomButton').onclick = openJoinRoomModal;
        document.getElementById('createRoomConfirm').onclick = createRoom;
        document.getElementById('joinRoomConfirm').onclick = joinRoom;
        document.getElementById('closeRoomModal').onclick = closeRoomModal;
        document.getElementById('closeJoinRoomModal').onclick = closeJoinRoomModal;
        document.getElementById('leaveRoomButton').onclick = leaveRoom;
        document.getElementById('roomOverlay').onclick = function(e) {
            if (e.target === document.getElementById('roomOverlay')) {
                closeRoomModal();
                closeJoinRoomModal();
            }
        };
        
        // Recording and Screenshot Functions
        function setupRecordingControls() {
            document.getElementById('recordButton').onclick = toggleRecording;
            document.getElementById('screenshotButton').onclick = takeScreenshot;
            document.getElementById('downloadScreenshot').onclick = downloadScreenshot;
            document.getElementById('shareScreenshot').onclick = shareScreenshot;
            document.getElementById('closeScreenshot').onclick = closeScreenshotPreview;
        }
        
        function toggleRecording() {
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }
        
        function startRecording() {
            if (!localStream && !remoteVideo.srcObject) {
                displayError('No video stream available for recording');
                return;
            }
            
            try {
                // Create a canvas to combine both video streams
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const localVideo = document.getElementById('localVideo');
                const remoteVideo = document.getElementById('remoteVideo');
                
                // Set canvas size based on video dimensions
                canvas.width = 1280;
                canvas.height = 720;
                
                // Create a stream from the canvas
                const canvasStream = canvas.captureStream(30);
                
                // Draw both videos on canvas continuously
                function drawFrame() {
                    if (!isRecording) return;
                    
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw remote video (main)
                    if (remoteVideo.videoWidth > 0) {
                        ctx.drawImage(remoteVideo, 0, 0, canvas.width, canvas.height);
                    }
                    
                    // Draw local video (picture-in-picture)
                    if (localVideo.videoWidth > 0) {
                        const pipWidth = canvas.width * 0.25;
                        const pipHeight = canvas.height * 0.25;
                        const pipX = canvas.width - pipWidth - 20;
                        const pipY = 20;
                        
                        ctx.drawImage(localVideo, pipX, pipY, pipWidth, pipHeight);
                        
                        // Add border to PiP
                        ctx.strokeStyle = '#007bff';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(pipX, pipY, pipWidth, pipHeight);
                    }
                    
                    requestAnimationFrame(drawFrame);
                }
                
                // Start drawing frames
                drawFrame();
                
                // Configure MediaRecorder
                const options = {
                    mimeType: 'video/webm;codecs=vp9',
                    videoBitsPerSecond: 2500000 // 2.5 Mbps
                };
                
                // Fallback to vp8 if vp9 is not supported
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'video/webm;codecs=vp8';
                }
                
                mediaRecorder = new MediaRecorder(canvasStream, options);
                recordedChunks = [];
                
                mediaRecorder.ondataavailable = function(event) {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = function() {
                    const blob = new Blob(recordedChunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    downloadRecording(url, blob);
                };
                
                mediaRecorder.start(1000); // Collect data every second
                isRecording = true;
                recordingStartTime = Date.now();
                
                // Update UI
                document.getElementById('recordButton').textContent = '‚èπÔ∏è Stop';
                document.getElementById('recordingIndicator').style.display = 'block';
                
                updateConnectionStatus('Recording started');
                
            } catch (error) {
                displayError('Failed to start recording: ' + error.message);
                console.error('Recording error:', error);
            }
        }
        
        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                
                // Update UI
                document.getElementById('recordButton').textContent = 'üî¥ Record';
                document.getElementById('recordingIndicator').style.display = 'none';
                
                const duration = Math.round((Date.now() - recordingStartTime) / 1000);
                updateConnectionStatus(`Recording stopped (${duration}s)`);
            }
        }
        
        function downloadRecording(url, blob) {
            const a = document.createElement('a');
            a.href = url;
            a.download = `webrtc-recording-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.webm`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // Show file size info
            const sizeKB = Math.round(blob.size / 1024);
            updateConnectionStatus(`Recording saved (${sizeKB} KB)`);
        }
        
        function takeScreenshot() {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const localVideo = document.getElementById('localVideo');
                const remoteVideo = document.getElementById('remoteVideo');
                
                // Set canvas size
                canvas.width = 1280;
                canvas.height = 720;
                
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw remote video (main)
                if (remoteVideo.videoWidth > 0) {
                    ctx.drawImage(remoteVideo, 0, 0, canvas.width, canvas.height);
                }
                
                // Draw local video (picture-in-picture)
                if (localVideo.videoWidth > 0) {
                    const pipWidth = canvas.width * 0.25;
                    const pipHeight = canvas.height * 0.25;
                    const pipX = canvas.width - pipWidth - 20;
                    const pipY = 20;
                    
                    ctx.drawImage(localVideo, pipX, pipY, pipWidth, pipHeight);
                    
                    // Add border to PiP
                    ctx.strokeStyle = '#007bff';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(pipX, pipY, pipWidth, pipHeight);
                }
                
                // Add timestamp
                ctx.fillStyle = '#fff';
                ctx.font = '20px Arial';
                ctx.fillText(new Date().toLocaleString(), 20, canvas.height - 20);
                
                // Convert to data URL and show preview
                const dataURL = canvas.toDataURL('image/png');
                showScreenshotPreview(dataURL);
                
                updateConnectionStatus('Screenshot captured');
                
            } catch (error) {
                displayError('Failed to take screenshot: ' + error.message);
                console.error('Screenshot error:', error);
            }
        }
        
        function showScreenshotPreview(dataURL) {
            const preview = document.getElementById('screenshotPreview');
            const img = document.getElementById('screenshotImage');
            
            img.src = dataURL;
            preview.style.display = 'flex';
            
            // Store for download/share
            preview.dataset.imageData = dataURL;
        }
        
        function downloadScreenshot() {
            const preview = document.getElementById('screenshotPreview');
            const dataURL = preview.dataset.imageData;
            
            if (dataURL) {
                const a = document.createElement('a');
                a.href = dataURL;
                a.download = `webrtc-screenshot-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                updateConnectionStatus('Screenshot downloaded');
            }
        }
        
        function shareScreenshot() {
            const preview = document.getElementById('screenshotPreview');
            const dataURL = preview.dataset.imageData;
            
            if (dataURL && navigator.share) {
                // Convert data URL to blob
                fetch(dataURL)
                    .then(res => res.blob())
                    .then(blob => {
                        const file = new File([blob], 'screenshot.png', { type: 'image/png' });
                        return navigator.share({
                            title: 'WebRTC Video Chat Screenshot',
                            files: [file]
                        });
                    })
                    .then(() => updateConnectionStatus('Screenshot shared'))
                    .catch(err => {
                        console.error('Share failed:', err);
                        // Fallback to copy to clipboard
                        copyToClipboard(dataURL);
                    });
            } else {
                // Fallback to copy to clipboard
                copyToClipboard(dataURL);
            }
        }
        
        function copyToClipboard(dataURL) {
            fetch(dataURL)
                .then(res => res.blob())
                .then(blob => {
                    const item = new ClipboardItem({ 'image/png': blob });
                    return navigator.clipboard.write([item]);
                })
                .then(() => updateConnectionStatus('Screenshot copied to clipboard'))
                .catch(err => {
                    console.error('Clipboard copy failed:', err);
                    displayError('Failed to copy screenshot');
                });
        }
        
        function closeScreenshotPreview() {
            const preview = document.getElementById('screenshotPreview');
            preview.style.display = 'none';
            delete preview.dataset.imageData;
        }
        
        // Initialize recording controls when the page loads
        setupRecordingControls();
        
        // Check authentication on page load
        if (!checkAuthentication()) {
            // User will be redirected to login
            return;
        }
    </script>
</body>
</html>
